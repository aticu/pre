//! Provides functions to generate documentation about the preconditions.

use quote::{quote, quote_spanned};
use std::{env, fmt::Write};
use syn::{
    spanned::Spanned,
    token::{Bracket, Pound},
    AttrStyle, Attribute, Ident, Path, Signature,
};

use crate::{helpers::HINT_REASON, pre_defs_for::ImplBlock, precondition::Precondition};

/// The base URL of the documentation for the `pre` crate.
const DOCS_URL: &str = concat!("https://docs.rs/pre/", env!("CARGO_PKG_VERSION"), "/pre",);

/// The required context for generating `impl` block documentation.
pub(crate) struct ImplBlockContext<'a> {
    /// The `impl` block that the item belongs to.
    pub(crate) impl_block: &'a ImplBlock,
    /// The path to the `impl` block.
    pub(crate) path: &'a Path,
    /// The name of the top level module that the `impl` block is contained in.
    pub(crate) top_level_module: &'a Ident,
}

/// Generates documentation of the preconditions for a function or method.
pub(crate) fn generate_docs(
    function: &Signature,
    preconditions: &[Precondition],
    impl_block_context: Option<ImplBlockContext>,
) -> Attribute {
    let span = function.span();
    let mut documentation = String::new();
    let plural = preconditions.len() != 1;

    macro_rules! doc {
        () => {
            writeln!(documentation).expect("string writes don't fail")
        };
        ($format_str:literal) => {
            writeln!(documentation, $format_str).expect("string writes don't fail")
        };
        ($format_str:literal, $($args:expr),*) => {
            writeln!(documentation, $format_str, $($args,)*).expect("string writes don't fail")
        };
    }

    if let Some(ctx) = &impl_block_context {
        doc!("# What is this function?");
        doc!();

        let path = &ctx.path;
        let ty = &ctx.impl_block.self_ty;
        let name = &function.ident;
        doc!(
            "This function has the preconditions for the `{}::{}::{}` function.",
            quote! { #path },
            quote! { #ty },
            quote! { #name }
        );
        doc!();
        doc!("It was generated by an `impl` block inside a [`pre_defs_for` attribute]({}/attr.pre_defs_for.html).", DOCS_URL);
        doc!("The impl block that this was generated in looks like this:");
        doc!();

        doc!("```rust,ignore");
        let ty = &ctx.impl_block.self_ty;
        let where_clause = &ctx.impl_block.generics.where_clause;
        let generics = if !ctx.impl_block.generics.params.is_empty() {
            Some(&ctx.impl_block.generics)
        } else {
            None
        };

        doc!(
            "impl{} {} {} {{",
            quote! { #generics },
            quote! { #ty },
            quote! { #where_clause }
        );

        doc!("    {};", quote! { #function });
        if ctx.impl_block.items.len() > 1 {
            doc!("    /* other items omitted */");
        }

        doc!("}}");
        doc!("```");
    }

    if !preconditions.is_empty() {
        doc!("# Preconditions");
        doc!();

        if plural {
            doc!("This function has the following preconditions generated by [`pre` attributes]({}/attr.pre.html):", DOCS_URL);
        } else {
            doc!("This function has the following precondition generated by the [`pre` attribute]({}/attr.pre.html):", DOCS_URL);
        }
        doc!();

        for precondition in preconditions {
            match precondition {
                Precondition::Custom(text) => doc!("- {}", text.value()),
                Precondition::ValidPtr {
                    ident, read_write, ..
                } => doc!(
                    "- the pointer `{}` must be valid for {}",
                    ident.to_string(),
                    read_write.doc_description()
                ),
            }
        }

        doc!();
        if plural {
            doc!("To call the function you need to [`assure`]({}/attr.assure.html) that the preconditions hold:", DOCS_URL);
        } else {
            doc!("To call the function you need to [`assure`]({}/attr.assure.html) that the precondition holds:", DOCS_URL);
        }
        doc!();
        doc!("```rust,ignore");

        if let Some(ctx) = &impl_block_context {
            let mut path_str = format!("{}", ctx.top_level_module);
            for segment in ctx.path.segments.iter().skip(1).chain(ctx.impl_block.ty()) {
                write!(path_str, "::{}", segment.ident).expect("string writes don't fail");
            }

            if let Ok(name) = env::var("CARGO_PKG_NAME") {
                let mut name = name.replace('-', "_");
                name.push_str("::");
                path_str.insert_str(0, &name);
            }

            doc!("#[forward(impl {})]", path_str);
        }

        for precondition in preconditions {
            doc!("#[assure({}, reason = {:?})]", precondition, HINT_REASON);
        }

        let receiver = if function.receiver().is_some() {
            "x."
        } else {
            ""
        };
        let parameters = if function.inputs.is_empty() {
            ""
        } else {
            "/* parameters omitted */"
        };
        doc!("{}{}({});", receiver, function.ident, parameters);

        doc!("```");
    }

    Attribute {
        pound_token: Pound { spans: [span] },
        style: AttrStyle::Outer,
        bracket_token: Bracket { span },
        path: Ident::new("doc", span).into(),
        tokens: quote_spanned! { span=>
            = #documentation
        },
    }
}
