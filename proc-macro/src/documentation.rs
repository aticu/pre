//! Provides functions to generate documentation about the preconditions.

use quote::quote_spanned;
use std::fmt::Write;
use syn::{
    spanned::Spanned,
    token::{Bracket, Pound},
    AttrStyle, Attribute, Ident, ItemFn,
};

use crate::{helpers::HINT_REASON, precondition::Precondition};

/// Generates documentation of the preconditions for a function or method.
pub(crate) fn generate_docs(function: &ItemFn, preconditions: &[Precondition]) -> Attribute {
    let span = function.span();
    let mut documentation = String::new();
    let plural = preconditions.len() != 1;

    macro_rules! doc {
        () => {
            writeln!(documentation).expect("string writes don't fail")
        };
        ($format_str:literal) => {
            writeln!(documentation, $format_str).expect("string writes don't fail")
        };
        ($format_str:literal, $($args:expr),*) => {
            writeln!(documentation, $format_str, $($args,)*).expect("string writes don't fail")
        };
    }

    doc!("# Preconditions");
    doc!();
    if plural {
        doc!("This function has the following preconditions generated by `pre` attributes:");
    } else {
        doc!("This function has the following precondition generated by the `pre` attribute:");
    }
    doc!();

    for precondition in preconditions {
        match precondition {
            Precondition::Custom(text) => doc!("- {}", text.value()),
            Precondition::ValidPtr {
                ident, read_write, ..
            } => doc!(
                "- the pointer `{}` must be valid for {}",
                ident.to_string(),
                read_write.doc_description()
            ),
        }
    }

    doc!();
    if plural {
        doc!("To call the function you need to assure that the preconditions hold:");
    } else {
        doc!("To call the function you need to assure that the precondition holds:");
    }
    doc!();
    doc!("```rust,ignore");

    for precondition in preconditions {
        doc!("#[assure({}, reason = {:?})]", precondition, HINT_REASON);
    }

    if function.sig.receiver().is_some() {
        doc!("x.{}(/* parameters omitted */);", function.sig.ident);
    } else {
        doc!("{}(/* parameters omitted */);", function.sig.ident);
    }
    doc!("```");

    Attribute {
        pound_token: Pound { spans: [span] },
        style: AttrStyle::Outer,
        bracket_token: Bracket { span },
        path: Ident::new("doc", span).into(),
        tokens: quote_spanned! { span=>
            = #documentation
        },
    }
}
