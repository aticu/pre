//! Provides functions to generate documentation about the preconditions.

use quote::{quote, quote_spanned};
use std::fmt::Write;
use syn::{
    spanned::Spanned,
    token::{Bracket, Pound},
    AttrStyle, Attribute, Ident, Signature,
};

use crate::{helpers::HINT_REASON, pre_defs_for::ImplBlock, precondition::Precondition};

/// Generates documentation of the preconditions for a function or method.
pub(crate) fn generate_docs(
    function: &Signature,
    preconditions: &[Precondition],
    impl_block: Option<&ImplBlock>,
) -> Attribute {
    let span = function.span();
    let mut documentation = String::new();
    let plural = preconditions.len() != 1;

    macro_rules! doc {
        () => {
            writeln!(documentation).expect("string writes don't fail")
        };
        ($format_str:literal) => {
            writeln!(documentation, $format_str).expect("string writes don't fail")
        };
        ($format_str:literal, $($args:expr),*) => {
            writeln!(documentation, $format_str, $($args,)*).expect("string writes don't fail")
        };
    }

    if let Some(impl_block) = impl_block {
        doc!("# What is this function?");
        doc!();
        doc!("This function was generated by an `impl` block inside a `pre_defs_for` attribute.");
        doc!("The impl block that this was generated in looks like this:");
        doc!();

        doc!("```rust,ignore");
        let ty = &impl_block.self_ty;
        let where_clause = &impl_block.generics.where_clause;
        let generics = if !impl_block.generics.params.is_empty() {
            Some(&impl_block.generics)
        } else {
            None
        };

        doc!(
            "impl{} {} {} {{",
            quote! { #generics },
            quote! { #ty },
            quote! { #where_clause }
        );

        doc!("    {};", quote! { #function });
        if impl_block.items.len() > 1 {
            doc!("    /* other items omitted */");
        }

        doc!("}}");
        doc!("```");
    }

    if !preconditions.is_empty() {
        doc!("# Preconditions");
        doc!();

        if plural {
            doc!("This function has the following preconditions generated by `pre` attributes:");
        } else {
            doc!("This function has the following precondition generated by the `pre` attribute:");
        }
        doc!();

        for precondition in preconditions {
            match precondition {
                Precondition::Custom(text) => doc!("- {}", text.value()),
                Precondition::ValidPtr {
                    ident, read_write, ..
                } => doc!(
                    "- the pointer `{}` must be valid for {}",
                    ident.to_string(),
                    read_write.doc_description()
                ),
            }
        }

        doc!();
        if plural {
            doc!("To call the function you need to assure that the preconditions hold:");
        } else {
            doc!("To call the function you need to assure that the precondition holds:");
        }
        doc!();
        doc!("```rust,ignore");

        for precondition in preconditions {
            doc!("#[assure({}, reason = {:?})]", precondition, HINT_REASON);
        }

        let receiver = if function.receiver().is_some() {
            "x."
        } else {
            ""
        };
        let parameters = if function.inputs.is_empty() {
            ""
        } else {
            "/* parameters omitted */"
        };
        doc!("{}{}({});", receiver, function.ident, parameters);

        doc!("```");
    }

    Attribute {
        pound_token: Pound { spans: [span] },
        style: AttrStyle::Outer,
        bracket_token: Bracket { span },
        path: Ident::new("doc", span).into(),
        tokens: quote_spanned! { span=>
            = #documentation
        },
    }
}
